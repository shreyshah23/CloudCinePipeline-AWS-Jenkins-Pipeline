# AWS-Jenkins-Pipeline

## Setting up a CI/CD pipeline by integrating Jenkins with AWS CodeBuild and AWS CodeDeploy
 
 
 
A working CI/CD pipeline is produced by deploying AWS CodeBuild artefacts with AWS CodeDeploy using the open-source Jenkins automation server.
The CI/CD pipeline is triggered by code changes committed to your GitHub repository, automatically fed into CodeBuild, and the output is deployed to CodeDeploy when fully implemented.
  
 
Your source code is compiled by a fully controlled build service that is created by a working pipeline. After that, it creates code artefacts that CodeDeploy may utilise to automatically deploy to your production environment.


![image](https://user-images.githubusercontent.com/48589838/89983289-e5fc2900-dc94-11ea-9258-685375cad1dd.png)



### Walkthrough 

assembling the necessary resources, such as the Jenkins server, the CodeBuild project, and the CodeDeploy application.

unlocking and gaining access to the Jenkins server.

establishing a project and setting up the Jenkins plugin for CodeDeploy.

testing every step of the CI/CD process.

### Create the resources
how to start an AWS CloudFormation template, a programme that generates the subsequent resources:

The files from the GitHub repository and the CodeBuild artefact application file that CodeDeploy utilises are kept in an Amazon S3 bucket.
The Jenkins server is given access to the S3 bucket by the IAM S3 bucket policy.
Using an Amazon EC2 instance as a Jenkins server requires the JenkinsRole IAM role and instance profile. With the help of this role, Jenkins running on the EC2 instance is able to write files to the S3 bucket and create CodeDeploy deployments.
Application and deployment group for CodeDeploy.
IAM role for the CodeDeploy service that enables CodeDeploy to access the tags applied to the instances or the names of the EC2 Auto Scaling groups connected to the instances
An IAM role and instance profile for CodeDeploy's EC2 instances is called CodeDeployRole. This role has the ability to create deployments in CodeDeploy and write files to the S3 bucket generated by this template.
CodeBuild will access the S3 bucket and generate the build projects using the CodeBuildRole IAM role.
An EC2 instance running Jenkins is the Jenkins server.
The S3 bucket and S3 artefact are configured with the CodeBuild project.
EC2 instances running Apache and the CodeDeploy agent are included in the auto-scaling group, which is protected by an elastic load balancer.
Launch configurations for auto scaling—Used by the auto scaling group.
Security groups—For the CodeDeploy EC2 instance, the load balancer, and the Jenkins server

![image](https://user-images.githubusercontent.com/48589838/89985330-87d14500-dc98-11ea-9964-c1211d0c8a03.png)

![image](https://user-images.githubusercontent.com/48589838/89985319-83a52780-dc98-11ea-8442-3e8e7eb3e403.png)


### Access and unlock your Jenkins server

From the CloudFormation stack's Outputs tab, copy the JenkinsServerDNSName value, and then paste it into your browser.

Use the IP address and key combination from Unlocking Jenkins to SSH to the server and follow the on-screen steps to unlock the Jenkins server.

To copy the automatically created alphanumeric password, Cat the log file (/var/log/jenkins/jenkins.log) as the root user (between the two sets of asterisks). Then, as seen in the following screenshots, use the password to unlock your Jenkins server.

![image](https://user-images.githubusercontent.com/48589838/89985442-ba7b3d80-dc98-11ea-9cb4-9014339ba6e3.png)

![image](https://user-images.githubusercontent.com/48589838/89985456-be0ec480-dc98-11ea-9f0a-32333a15e9ce.png)

![image](https://user-images.githubusercontent.com/48589838/89985477-c666ff80-dc98-11ea-8313-dcdec60d39f8.png)

![image](https://user-images.githubusercontent.com/48589838/89985469-c23ae200-dc98-11ea-9243-9c8994fa4f28.png)



### Create a project and configure the CodeDeploy Jenkins plugin

![image](https://user-images.githubusercontent.com/48589838/89985612-fadabb80-dc98-11ea-84cf-c2add128ffc0.png)
![image](https://user-images.githubusercontent.com/48589838/89985621-ff06d900-dc98-11ea-9fee-f80963c8291f.png)
![image](https://user-images.githubusercontent.com/48589838/89985634-05955080-dc99-11ea-9187-db635bdeca9a.png)
![image](https://user-images.githubusercontent.com/48589838/89985688-15149980-dc99-11ea-8810-8e7a43c1e4ff.png)
![image](https://user-images.githubusercontent.com/48589838/89985702-1c3ba780-dc99-11ea-90c3-220b906d91a7.png)
![image](https://user-images.githubusercontent.com/48589838/89985709-1fcf2e80-dc99-11ea-8caf-4962b2721915.png)
![image](https://user-images.githubusercontent.com/48589838/89985726-25c50f80-dc99-11ea-9955-68b7897cb6db.png)
![image](https://user-images.githubusercontent.com/48589838/89985715-22ca1f00-dc99-11ea-9fe5-4a1b0c79e65c.png)
![image](https://user-images.githubusercontent.com/48589838/89985694-180f8a00-dc99-11ea-8a3c-fa211b9ea87e.png)
![image](https://user-images.githubusercontent.com/48589838/89985744-28c00000-dc99-11ea-8e62-e3d18baa5152.png)
![image](https://user-images.githubusercontent.com/48589838/89985756-2c538700-dc99-11ea-9318-a0cb7a6aed0a.png)
![image](https://user-images.githubusercontent.com/48589838/89985781-31b0d180-dc99-11ea-969e-407595b211ad.png)
![image](https://user-images.githubusercontent.com/48589838/89985795-35dcef00-dc99-11ea-816f-2ce6a2bacece.png)
![image](https://user-images.githubusercontent.com/48589838/89985806-38d7df80-dc99-11ea-8cd8-b003ccac1c45.png)
![image](https://user-images.githubusercontent.com/48589838/89985848-45f4ce80-dc99-11ea-9a47-c8256c083864.png)
![image](https://user-images.githubusercontent.com/48589838/89985864-4a20ec00-dc99-11ea-8dbf-fcecdedec7e6.png)
![image](https://user-images.githubusercontent.com/48589838/89985875-4db47300-dc99-11ea-8288-fb7e30a5cb11.png)


### Testing the whole CI/CD pipeline

Create an application and upload it to your GitHub repository to test the entire solution.

An application tree including the application's source files, including text and binary files, executables, and packages, can be seen in the following screenshot:

![image](https://user-images.githubusercontent.com/48589838/89986084-a71ca200-dc99-11ea-9021-097d82084171.png)

The application files in this illustration are the templates directory, test app.py, and web.py.

The primary application specification file that instructs CodeDeploy how to deploy your application is called appspec.yml. Jenkins manages each deployment as a set of defined lifecycle event "hooks" using the AppSpec file. AWS CodeDeploy AppSpec File Reference contains instructions on how to generate an AppSpec file that is correctly formatted.

CodeBuild uses the buildspec.yml file, which is a collection of build instructions and associated settings, to do builds. A build spec can be defined when you start a build project or it can be included as part of the source code. How AWS CodeBuild Works has further information.

The scripts folder contains the scripts that you would like to run during the CodeDeploy LifecycleHooks execution with respect to your application requirements. For more information, see Plan a Revision for AWS CodeDeploy.

To test this solution, perform the following steps:

Unzip the application files and send them to your GitHub repository, run the following git commands from the path where you placed your sample application:

$ git add -A

$ git commit -m 'Your first application'

$ git push
On the Jenkins server dashboard, wait for two minutes until the previously set project trigger starts working. After the trigger starts working, you should see a new build taking place.

![image](https://user-images.githubusercontent.com/48589838/89986214-d92e0400-dc99-11ea-84cb-9ff3e830a1b8.png)

In the Jenkins server Console Output page, check the build events and review the steps performed by each Jenkins plugin. You can also review the CodeDeploy deployment in detail, as shown in the following screenshot:

![image](https://user-images.githubusercontent.com/48589838/89986227-dd5a2180-dc99-11ea-95a5-15938ac49df1.png)

On completion, Jenkins should report that you have successfully deployed a web application. You can also use your ELBDNSName value to confirm that the deployed application is running successfully.

![image](https://user-images.githubusercontent.com/48589838/89986033-9409d200-dc99-11ea-883c-37f6a469e02c.png)
